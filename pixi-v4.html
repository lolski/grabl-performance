<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.2.4/pixi.min.js"></script>
    </head>
    <body style="background-color: #180e29;">
        <div id="chart" style=" width: 1000px; margin: 0 auto;"></div>
    </body>
    <script type="text/javascript">
    class TraceGroupLine {
        // public
        constructor(traceGroup) {
            this.line = TraceGroupLine.paintTraceGroupLineInteractive(traceGroup);
        }
        getPaintings() {
            return this.line;
        }
        
        // private
        static paintTraceGroupLineInteractive(traceGroup) {
            let line = TraceGroupLine.createLine();
            line.on('pointerover', (event) => {
                TraceGroupLine.paintTraceGroupLine({width: 1, color: 0x0000FF, alpha: 1}, line, traceGroup);
            });
            line.on('pointerout', (event) => {
                TraceGroupLine.paintTraceGroupLine({width: 1, color: 0xFF0000, alpha: 1}, line, traceGroup);
            });
            TraceGroupLine.paintTraceGroupLine({width: 1, color: 0xFF0000, alpha: 1}, line, traceGroup);
            return line;
        }
        static paintTraceGroupLine(style, line, traceGroup) {
            line.clear();
            line.lineStyle(style);
            line.moveTo(0, 0);
            for (const key in traceGroup) {
                line.lineTo(
                    traceGroup[key].iteration * 100,
                    traceGroup[key].duration
                )
            }
        }
        static createLine() {
            let line = new PIXI.Graphics();
            line.interactive = true;
            
            line.geometry.containsPoint = function containsPoint(point) {
                var graphicsData = this.graphicsData;
                
                for (var i = 0; i < graphicsData.length; ++i) {
                    var data = graphicsData[i];
                    
                    if (data.shape) {
                        var tmpPoint = new PIXI.Point();
                        if (data.matrix) {
                            data.matrix.applyInverse(point, tmpPoint);
                        }
                        else {
                            tmpPoint.copyFrom(point);
                        }
                        let hit = false;
                        // define bounding box
                        for (let i = 0; i <= data.points.length - 4; i += 2) {
                            let x1 = data.points[i];
                            let y1 = data.points[i+1];
                            let x2 = data.points[i+2];
                            let y2 = data.points[i+3];
                            let m = (y2-y1) / (x2-x1);
                            
                            // the bounding box is kinda buggy tho
                            var withinBoundingBox =
                                tmpPoint.x >= x1 && tmpPoint.x <= x2 &&
                                tmpPoint.y >= y1 && tmpPoint.y <= y2;
                            if (withinBoundingBox) {
                                if (
                                    (tmpPoint.y-y1) >= m*(tmpPoint.x-x1)-10 &&
                                    (tmpPoint.y-y1) <= m*(tmpPoint.x-x1)+10
                                ) {
                                    hit = true;
                                    break;
                                }
                            }
                        }
                        return hit;
                    }
                }

                return false;
            }
            return line;
        }
    }
    class TraceGroupsCanvas {
        // public
        constructor(style, traceGroups) {
            this.style = style;
            this.display = TraceGroupsCanvas.createDisplay(style);
            this.setTraceGroups(traceGroups);
        }
        setTraceGroups(traceGroups) { 
            this.display.stage.removeChildren();
            this.updateDisplay(traceGroups);
        }
        setDimension(dimension) {}
        setXAxisMode(mode) {}
        setViewMode(mode) {}
        selectLine(line) {}
        getDisplay() {
            return this.display.view;
        }
        // private
        static createDisplay(style) {
            let display = new PIXI.Application({ width: style.width, height: style.height, backgroundColor: 0xFFFFFF });this.display = new PIXI.Application({ width: style.width, height: style.height, backgroundColor: 0xFFFFFF });
            display.stage.position.y = style.height;
            display.stage.scale.y = -1;
            return display;
        }
        updateDisplay(traceGroups) {
            let container = new PIXI.Container();
            container.position.x = 20;
            container.position.y = 20;
            let width = this.style.width - 20*2;
            let height = this.style.height - 20*2;
            let xaxis = TraceGroupsCanvas.paintXAxis(width);
            container.addChild(xaxis);
            let yaxis = TraceGroupsCanvas.paintYAxis(height);
            container.addChild(yaxis);
            let lines = TraceGroupsCanvas.paintTraceGroupLines(traceGroups);
            container.addChild(lines);
            this.display.stage.addChild(container);
        }
        static paintTraceGroupLines(traceGroups) {
            let container = new PIXI.Container();
            for (const key in traceGroups) {
                container.addChild(new TraceGroupLine(traceGroups[key].traces).getPaintings());
            }
            return container;
        }
        static paintXAxis(width) {
            let xaxis = new PIXI.Graphics();
            xaxis.lineStyle({width: 1, color: 0x000000, alpha: 1})
            xaxis.moveTo(0, 0);
            xaxis.lineTo(width, 0);
            return xaxis;
        }
        static paintYAxis(height) {
            let yaxis = new PIXI.Graphics();
            yaxis.lineStyle({width: 1, color: 0x000000, alpha: 1})
            yaxis.moveTo(0, 0);
            yaxis.lineTo(0, height);
            return yaxis;
        }
    }
    //
    // main
    //
    var traceGroups = {
        "client.tx.execute.insert:server.tx.stream.insert:query.insert": {
            "traces": {
                "ab23fe56a7823d3d": {
                    "id": "ab23fe56a7823d3d",
                    "iteration": 1,
                    "duration": 205
                },
                "773bfe65a7823daf": {
                    "id": "773bfe65a7823daf",
                    "iteration": 2,
                    "duration": 50
                },
                "f144fe6ba7823dea": {
                    "id": "f144fe6ba7823dea",
                    "iteration": 3,
                    "duration": 52
                },
                "ca782356a773bfeb": {
                    "id": "ca782356a773bfeb",
                    "iteration": 4,
                    "duration": 71
                }
            }
        },
        "client.tx.commit:server.tx.commit": {
            "traces": {
                "23d3dae56a78b23f": {
                    "id": "23d3dae56a78b23f",
                    "iteration": 1,
                    "duration": 225
                },
                "a7827653daf73bfe": {
                    "id": "a7827653daf73bfe",
                    "iteration": 3,
                    "duration": 250
                },
                "a784fe6bde23f14a": {
                    "id": "a784fe6bde23f14a",
                    "iteration": 4,
                    "duration": 252
                },
                "3bfeb356a77ca782": {
                    "id": "3bfeb356a77ca782",
                    "iteration": 6,
                    "duration": 171
                }
            }
        }
    };
    var traceGroupsCanvas = new TraceGroupsCanvas({width: 1000, height: 600}, traceGroups);
    document.querySelector("#chart").appendChild(traceGroupsCanvas.getDisplay());
    // update dimension: traceGroupsCanvas.setDimension({width: 400, height: 300});
    // update data: traceGroupsCanvas.setTraceGroups(traceGroups);
    // display Iteration/Time: traceGroupsCanvas.setXAxisMode(Mode.ITERATION / Mode.TIME)
    // display Line/Trend: traceGroupsCanvas.setViewMode(Mode.LINE / Mode.TREND)
    // select a single line: traceGroupsCanvas.selectLine(
    //   'client.tx.execute.insert:server.tx.stream.insert:query.insert'
    // )
</script>
</html>